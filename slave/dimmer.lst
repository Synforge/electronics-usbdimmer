   1               		.file	"dimmer.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	initIO
  11               	initIO:
  12               	.LFB7:
  13               		.file 1 "dimmer.c"
   1:dimmer.c      **** #include <dimmer.h>
   2:dimmer.c      **** 
   3:dimmer.c      **** #include <avr/io.h>
   4:dimmer.c      **** #include <avr/interrupt.h>
   5:dimmer.c      **** #include <avr/pgmspace.h>
   6:dimmer.c      **** #include <avr/eeprom.h>
   7:dimmer.c      **** #include <avr/wdt.h>
   8:dimmer.c      **** 
   9:dimmer.c      **** #include <util/delay.h>
  10:dimmer.c      **** 
  11:dimmer.c      **** #define DIMMER_COUNT 2
  12:dimmer.c      **** #define TRUE 1
  13:dimmer.c      **** #define FALSE 0
  14:dimmer.c      **** 
  15:dimmer.c      **** #define MAX_SIZE 2048
  16:dimmer.c      **** 
  17:dimmer.c      **** #define DEBUG_DDR DDRC
  18:dimmer.c      **** #define DEBUG_PORT PORTC
  19:dimmer.c      **** #define DEBUG_LED PC5
  20:dimmer.c      **** 
  21:dimmer.c      **** static const char CMD_SET = 0x01; // Set command e.g. [0x01 (command), 0x00(method), 0x01(index) 0x
  22:dimmer.c      **** 
  23:dimmer.c      **** static const char METHOD_SWITCH = 0x00;
  24:dimmer.c      **** static const char METHOD_RAMP = 0x01;
  25:dimmer.c      **** 
  26:dimmer.c      **** struct dimmer {
  27:dimmer.c      **** 	volatile uint8_t level_cur;
  28:dimmer.c      **** 	volatile uint8_t level_req;
  29:dimmer.c      **** 	volatile uint8_t *port;
  30:dimmer.c      **** 	uint8_t mask;	
  31:dimmer.c      **** } dimmers[DIMMER_COUNT];
  32:dimmer.c      **** 
  33:dimmer.c      **** void initIO (void)
  34:dimmer.c      **** {
  14               		.loc 1 34 0
  15               	/* prologue: function */
  16               	/* frame size = 0 */
  17               	/* stack size = 0 */
  18               	.L__stack_usage = 0
  35:dimmer.c      **** 	//Set the debug LED as output
  36:dimmer.c      **** 	DEBUG_DDR = (1<<DEBUG_LED);
  19               		.loc 1 36 0
  20 0000 80E2      		ldi r24,lo8(32)
  21 0002 87B9      		out 0x7,r24
  37:dimmer.c      **** 
  38:dimmer.c      **** 	//INT0 - ZCD
  39:dimmer.c      **** 	EICRA = (1<<ISC01) | (0<<ISC00);
  22               		.loc 1 39 0
  23 0004 82E0      		ldi r24,lo8(2)
  24 0006 8093 6900 		sts 105,r24
  40:dimmer.c      **** 	EIMSK |= (1<<INT0);
  25               		.loc 1 40 0
  26 000a E89A      		sbi 0x1d,0
  41:dimmer.c      **** 
  42:dimmer.c      **** 	//Dimming Timer (TODO: Enable/Disable on Dimming request).
  43:dimmer.c      **** 	TCCR0A = 	(1 << WGM01);
  27               		.loc 1 43 0
  28 000c 84BD      		out 0x24,r24
  44:dimmer.c      **** 	TCCR0B = 	((1 << CS02) | (1 << CS00));		// CTC Mode - Prescaler 1024
  29               		.loc 1 44 0
  30 000e 95E0      		ldi r25,lo8(5)
  31 0010 95BD      		out 0x25,r25
  45:dimmer.c      **** 	OCR0A = 	156;								// ~10ms
  32               		.loc 1 45 0
  33 0012 9CE9      		ldi r25,lo8(-100)
  34 0014 97BD      		out 0x27,r25
  46:dimmer.c      **** 	TIMSK0 = 	(1 << OCIE0A);
  35               		.loc 1 46 0
  36 0016 8093 6E00 		sts 110,r24
  47:dimmer.c      **** 
  48:dimmer.c      **** 	//Set up SPI
  49:dimmer.c      **** 	DDRB &= ~((1<<2)|(1<<3)|(1<<5));   // SCK, MOSI and SS as inputs
  37               		.loc 1 49 0
  38 001a 84B1      		in r24,0x4
  39 001c 837D      		andi r24,lo8(-45)
  40 001e 84B9      		out 0x4,r24
  50:dimmer.c      ****     DDRB |= (1<<4);                    // MISO as output
  41               		.loc 1 50 0
  42 0020 249A      		sbi 0x4,4
  51:dimmer.c      **** 
  52:dimmer.c      ****     SPCR &= ~(1<<MSTR);                // Set as slave 
  43               		.loc 1 52 0
  44 0022 8CB5      		in r24,0x2c
  45 0024 8F7E      		andi r24,lo8(-17)
  46 0026 8CBD      		out 0x2c,r24
  53:dimmer.c      ****     SPCR |= (1<<SPR0)|(1<<SPR1);       // divide clock by 128
  47               		.loc 1 53 0
  48 0028 8CB5      		in r24,0x2c
  49 002a 8360      		ori r24,lo8(3)
  50 002c 8CBD      		out 0x2c,r24
  54:dimmer.c      ****     SPCR |= (1<<SPE);                  // Enable SPI
  51               		.loc 1 54 0
  52 002e 8CB5      		in r24,0x2c
  53 0030 8064      		ori r24,lo8(64)
  54 0032 8CBD      		out 0x2c,r24
  55:dimmer.c      **** 
  56:dimmer.c      **** 	sei();
  55               		.loc 1 56 0
  56               	/* #APP */
  57               	 ;  56 "dimmer.c" 1
  58 0034 7894      		sei
  59               	 ;  0 "" 2
  60               	/* #NOAPP */
  61 0036 0895      		ret
  62               	.LFE7:
  64               	.global	initDimmers
  66               	initDimmers:
  67               	.LFB8:
  57:dimmer.c      **** }
  58:dimmer.c      **** 
  59:dimmer.c      **** void initDimmers(void) {
  68               		.loc 1 59 0
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  60:dimmer.c      **** 	//Set up the Data Direction Register
  61:dimmer.c      **** 	DDRD = (1<<PD0) | (1<<PD1);
  73               		.loc 1 61 0
  74 0038 83E0      		ldi r24,lo8(3)
  75 003a 8AB9      		out 0xa,r24
  62:dimmer.c      **** 	//Set the triacs off.
  63:dimmer.c      **** 	PORTD = 0x00;
  76               		.loc 1 63 0
  77 003c 8BE2      		ldi r24,lo8(43)
  78 003e 90E0      		ldi r25,0
  79 0040 1BB8      		out 0xb,__zero_reg__
  64:dimmer.c      **** 
  65:dimmer.c      **** 	dimmers[0].level_cur = 0;
  80               		.loc 1 65 0
  81 0042 1092 0000 		sts dimmers,__zero_reg__
  66:dimmer.c      **** 	dimmers[0].level_req = 0;
  82               		.loc 1 66 0
  83 0046 1092 0000 		sts dimmers+1,__zero_reg__
  67:dimmer.c      **** 	dimmers[0].port = &PORTD;
  84               		.loc 1 67 0
  85 004a 9093 0000 		sts dimmers+2+1,r25
  86 004e 8093 0000 		sts dimmers+2,r24
  68:dimmer.c      **** 	dimmers[0].mask = (1<<PD0);
  87               		.loc 1 68 0
  88 0052 21E0      		ldi r18,lo8(1)
  89 0054 2093 0000 		sts dimmers+4,r18
  69:dimmer.c      **** 	
  70:dimmer.c      **** 	dimmers[1].level_cur = 0;
  90               		.loc 1 70 0
  91 0058 1092 0000 		sts dimmers+5,__zero_reg__
  71:dimmer.c      **** 	dimmers[1].level_req = 0;
  92               		.loc 1 71 0
  93 005c 1092 0000 		sts dimmers+6,__zero_reg__
  72:dimmer.c      **** 	dimmers[1].port = &PORTD;
  94               		.loc 1 72 0
  95 0060 9093 0000 		sts dimmers+7+1,r25
  96 0064 8093 0000 		sts dimmers+7,r24
  73:dimmer.c      **** 	dimmers[1].mask = (1<<PD1);
  97               		.loc 1 73 0
  98 0068 82E0      		ldi r24,lo8(2)
  99 006a 8093 0000 		sts dimmers+9,r24
 100 006e 0895      		ret
 101               	.LFE8:
 103               		.section	.text.startup,"ax",@progbits
 104               	.global	main
 106               	main:
 107               	.LFB9:
  74:dimmer.c      **** }
  75:dimmer.c      **** 
  76:dimmer.c      **** int main (void)
  77:dimmer.c      **** {
 108               		.loc 1 77 0
 109 0000 CF93      		push r28
 110               	.LCFI0:
 111 0002 DF93      		push r29
 112               	.LCFI1:
 113 0004 00D0      		rcall .
 114 0006 00D0      		rcall .
 115               	.LCFI2:
 116 0008 CDB7      		in r28,__SP_L__
 117 000a DEB7      		in r29,__SP_H__
 118               	.LCFI3:
 119               	/* prologue: function */
 120               	/* frame size = 4 */
 121               	/* stack size = 6 */
 122               	.L__stack_usage = 6
  78:dimmer.c      **** 	initIO(); //Setup IO pins and defaults
 123               		.loc 1 78 0
 124 000c 00D0      		rcall initIO
 125               	.LVL0:
  79:dimmer.c      **** 	initDimmers(); //Set up the dimmers.
 126               		.loc 1 79 0
 127 000e 00D0      		rcall initDimmers
 128               	.LVL1:
  80:dimmer.c      **** 
  81:dimmer.c      **** 	char commandBuffer[4];
  82:dimmer.c      **** 	uint8_t count = 0;
 129               		.loc 1 82 0
 130 0010 80E0      		ldi r24,0
  83:dimmer.c      **** 
  84:dimmer.c      **** 	while(1) {
  85:dimmer.c      **** 
  86:dimmer.c      **** 		while(!(SPSR & (1<<SPIF)));
  87:dimmer.c      **** 
  88:dimmer.c      ****         commandBuffer[count++] = SPDR;
  89:dimmer.c      **** 
  90:dimmer.c      ****         if(commandBuffer[0] == CMD_SET && count == 4) {
  91:dimmer.c      ****         	//We have all our data        	
  92:dimmer.c      ****         	if(commandBuffer[1] == METHOD_SWITCH) {
  93:dimmer.c      ****         		switchToLevel((uint8_t)commandBuffer[2], (uint8_t)commandBuffer[3]);
  94:dimmer.c      ****         	} else {
  95:dimmer.c      **** 				rampToLevel((uint8_t)commandBuffer[2], (uint8_t)commandBuffer[3]);
  96:dimmer.c      ****         	}
  97:dimmer.c      **** 
  98:dimmer.c      ****         	//Toggle the Debug LED
  99:dimmer.c      ****         	DEBUG_PORT ^= (1 << DEBUG_LED);
 131               		.loc 1 99 0
 132 0012 20E2      		ldi r18,lo8(32)
 133               	.LBB9:
 134               	.LBB10:
 100:dimmer.c      **** 
 101:dimmer.c      ****         	count = 0;
 102:dimmer.c      ****         }
 103:dimmer.c      **** 
 104:dimmer.c      **** 	}
 105:dimmer.c      **** 
 106:dimmer.c      **** 	return(0);
 107:dimmer.c      **** }
 108:dimmer.c      **** 
 109:dimmer.c      **** void rampToLevel(uint8_t index, uint8_t level) {
 110:dimmer.c      **** 	if(level > 255)
 111:dimmer.c      **** 		level = 255;
 112:dimmer.c      **** 	
 113:dimmer.c      **** 	if(level < 0 ) 
 114:dimmer.c      **** 		level = 0;
 115:dimmer.c      **** 	
 116:dimmer.c      **** 	dimmers[index].level_req = level;
 135               		.loc 1 116 0
 136 0014 95E0      		ldi r25,lo8(5)
 137               	.LVL2:
 138               	.L11:
 139               	.LBE10:
 140               	.LBE9:
  86:dimmer.c      **** 		while(!(SPSR & (1<<SPIF)));
 141               		.loc 1 86 0 discriminator 1
 142 0016 0DB4      		in __tmp_reg__,0x2d
 143 0018 07FE      		sbrs __tmp_reg__,7
 144 001a 00C0      		rjmp .L11
  88:dimmer.c      ****         commandBuffer[count++] = SPDR;
 145               		.loc 1 88 0
 146 001c 3EB5      		in r19,0x2e
 147 001e E1E0      		ldi r30,lo8(1)
 148 0020 F0E0      		ldi r31,0
 149 0022 EC0F      		add r30,r28
 150 0024 FD1F      		adc r31,r29
 151 0026 E80F      		add r30,r24
 152 0028 F11D      		adc r31,__zero_reg__
 153 002a 3083      		st Z,r19
 154 002c 8F5F      		subi r24,lo8(-(1))
 155               	.LVL3:
  90:dimmer.c      ****         if(commandBuffer[0] == CMD_SET && count == 4) {
 156               		.loc 1 90 0
 157 002e 3981      		ldd r19,Y+1
 158 0030 3130      		cpi r19,lo8(1)
 159 0032 01F4      		brne .L11
  90:dimmer.c      ****         if(commandBuffer[0] == CMD_SET && count == 4) {
 160               		.loc 1 90 0 is_stmt 0 discriminator 1
 161 0034 8430      		cpi r24,lo8(4)
 162 0036 01F4      		brne .L11
  92:dimmer.c      ****         	if(commandBuffer[1] == METHOD_SWITCH) {
 163               		.loc 1 92 0 is_stmt 1
 164 0038 3A81      		ldd r19,Y+2
 165 003a 8C81      		ldd r24,Y+4
 166               	.LVL4:
 167 003c EB81      		ldd r30,Y+3
 168               	.LBB11:
 169               	.LBB12:
 117:dimmer.c      **** }
 118:dimmer.c      **** 
 119:dimmer.c      **** void switchToLevel(uint8_t index, uint8_t level) {
 120:dimmer.c      **** 	if(level > 255)
 121:dimmer.c      **** 		level = 255;
 122:dimmer.c      **** 	
 123:dimmer.c      **** 	if(level < 0 ) 
 124:dimmer.c      **** 		level = 0;
 125:dimmer.c      **** 
 126:dimmer.c      **** 	dimmers[index].level_req = level;
 170               		.loc 1 126 0
 171 003e 9E9F      		mul r25,r30
 172 0040 F001      		movw r30,r0
 173 0042 1124      		clr __zero_reg__
 174 0044 E050      		subi r30,lo8(-(dimmers))
 175 0046 F040      		sbci r31,hi8(-(dimmers))
 176 0048 8183      		std Z+1,r24
 177               	.LBE12:
 178               	.LBE11:
  92:dimmer.c      ****         	if(commandBuffer[1] == METHOD_SWITCH) {
 179               		.loc 1 92 0
 180 004a 3111      		cpse r19,__zero_reg__
 181 004c 00C0      		rjmp .L8
 182               	.LVL5:
 183               	.LBB14:
 184               	.LBB13:
 127:dimmer.c      **** 	dimmers[index].level_cur = level;
 185               		.loc 1 127 0
 186 004e 8083      		st Z,r24
 187               	.LVL6:
 188               	.L8:
 189               	.LBE13:
 190               	.LBE14:
  99:dimmer.c      ****         	DEBUG_PORT ^= (1 << DEBUG_LED);
 191               		.loc 1 99 0
 192 0050 88B1      		in r24,0x8
 193 0052 8227      		eor r24,r18
 194 0054 88B9      		out 0x8,r24
 195               	.LVL7:
 101:dimmer.c      ****         	count = 0;
 196               		.loc 1 101 0
 197 0056 80E0      		ldi r24,0
 198 0058 00C0      		rjmp .L11
 199               	.LFE9:
 201               		.text
 202               	.global	rampToLevel
 204               	rampToLevel:
 205               	.LFB10:
 109:dimmer.c      **** void rampToLevel(uint8_t index, uint8_t level) {
 206               		.loc 1 109 0
 207               	.LVL8:
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 0 */
 211               	.L__stack_usage = 0
 116:dimmer.c      **** 	dimmers[index].level_req = level;
 212               		.loc 1 116 0
 213 0070 95E0      		ldi r25,lo8(5)
 214 0072 899F      		mul r24,r25
 215 0074 F001      		movw r30,r0
 216 0076 1124      		clr __zero_reg__
 217 0078 E050      		subi r30,lo8(-(dimmers))
 218 007a F040      		sbci r31,hi8(-(dimmers))
 219 007c 6183      		std Z+1,r22
 220 007e 0895      		ret
 221               	.LFE10:
 223               	.global	switchToLevel
 225               	switchToLevel:
 226               	.LFB11:
 119:dimmer.c      **** void switchToLevel(uint8_t index, uint8_t level) {
 227               		.loc 1 119 0
 228               	.LVL9:
 229               	/* prologue: function */
 230               	/* frame size = 0 */
 231               	/* stack size = 0 */
 232               	.L__stack_usage = 0
 126:dimmer.c      **** 	dimmers[index].level_req = level;
 233               		.loc 1 126 0
 234 0080 95E0      		ldi r25,lo8(5)
 235 0082 899F      		mul r24,r25
 236 0084 F001      		movw r30,r0
 237 0086 1124      		clr __zero_reg__
 238 0088 E050      		subi r30,lo8(-(dimmers))
 239 008a F040      		sbci r31,hi8(-(dimmers))
 240 008c 6183      		std Z+1,r22
 241               		.loc 1 127 0
 242 008e 6083      		st Z,r22
 243 0090 0895      		ret
 244               	.LFE11:
 246               	.global	debugLed
 248               	debugLed:
 249               	.LFB12:
 128:dimmer.c      **** }
 129:dimmer.c      **** 
 130:dimmer.c      **** void debugLed(uint8_t state) {
 250               		.loc 1 130 0
 251               	.LVL10:
 252               	/* prologue: function */
 253               	/* frame size = 0 */
 254               	/* stack size = 0 */
 255               	.L__stack_usage = 0
 131:dimmer.c      **** 	DEBUG_PORT = (state<<DEBUG_LED);
 256               		.loc 1 131 0
 257 0092 8295      		swap r24
 258               	.LVL11:
 259 0094 880F      		lsl r24
 260 0096 807E      		andi r24,lo8(-32)
 261 0098 88B9      		out 0x8,r24
 262 009a 0895      		ret
 263               	.LFE12:
 265               	.global	__vector_1
 267               	__vector_1:
 268               	.LFB13:
 132:dimmer.c      **** }
 133:dimmer.c      **** 
 134:dimmer.c      **** volatile uint16_t count;
 135:dimmer.c      **** //Zero Cross Detection.
 136:dimmer.c      **** ISR(INT0_vect) {
 269               		.loc 1 136 0
 270 009c 1F92      		push r1
 271               	.LCFI4:
 272 009e 0F92      		push r0
 273               	.LCFI5:
 274 00a0 0FB6      		in r0,__SREG__
 275 00a2 0F92      		push r0
 276 00a4 1124      		clr __zero_reg__
 277 00a6 8F93      		push r24
 278               	.LCFI6:
 279 00a8 9F93      		push r25
 280               	.LCFI7:
 281 00aa EF93      		push r30
 282               	.LCFI8:
 283 00ac FF93      		push r31
 284               	.LCFI9:
 285               	/* prologue: Signal */
 286               	/* frame size = 0 */
 287               	/* stack size = 7 */
 288               	.L__stack_usage = 7
 137:dimmer.c      **** 	count = 256;
 289               		.loc 1 137 0
 290 00ae 80E0      		ldi r24,0
 291 00b0 91E0      		ldi r25,lo8(1)
 292 00b2 9093 0000 		sts count+1,r25
 293 00b6 8093 0000 		sts count,r24
 138:dimmer.c      **** 
 139:dimmer.c      **** 	TCCR1B |= 	((1 << CS10) | (1 << WGM12));
 294               		.loc 1 139 0
 295 00ba E1E8      		ldi r30,lo8(-127)
 296 00bc F0E0      		ldi r31,0
 297 00be 8081      		ld r24,Z
 298 00c0 8960      		ori r24,lo8(9)
 299 00c2 8083      		st Z,r24
 140:dimmer.c      **** 	OCR1A = 	400;
 300               		.loc 1 140 0
 301 00c4 80E9      		ldi r24,lo8(-112)
 302 00c6 91E0      		ldi r25,lo8(1)
 303 00c8 9093 8900 		sts 136+1,r25
 304 00cc 8093 8800 		sts 136,r24
 141:dimmer.c      **** 	TIMSK1 |= 	(1 << OCIE1A);	
 305               		.loc 1 141 0
 306 00d0 EFE6      		ldi r30,lo8(111)
 307 00d2 F0E0      		ldi r31,0
 308 00d4 8081      		ld r24,Z
 309 00d6 8260      		ori r24,lo8(2)
 310 00d8 8083      		st Z,r24
 311               	/* epilogue start */
 142:dimmer.c      **** }
 312               		.loc 1 142 0
 313 00da FF91      		pop r31
 314 00dc EF91      		pop r30
 315 00de 9F91      		pop r25
 316 00e0 8F91      		pop r24
 317 00e2 0F90      		pop r0
 318 00e4 0FBE      		out __SREG__,r0
 319 00e6 0F90      		pop r0
 320 00e8 1F90      		pop r1
 321 00ea 1895      		reti
 322               	.LFE13:
 324               	.global	__vector_11
 326               	__vector_11:
 327               	.LFB14:
 143:dimmer.c      **** 
 144:dimmer.c      **** //Zero Cross Timer Interrupt.
 145:dimmer.c      **** ISR(TIMER1_COMPA_vect) {
 328               		.loc 1 145 0
 329 00ec 1F92      		push r1
 330               	.LCFI10:
 331 00ee 0F92      		push r0
 332               	.LCFI11:
 333 00f0 0FB6      		in r0,__SREG__
 334 00f2 0F92      		push r0
 335 00f4 1124      		clr __zero_reg__
 336 00f6 2F93      		push r18
 337               	.LCFI12:
 338 00f8 3F93      		push r19
 339               	.LCFI13:
 340 00fa 4F93      		push r20
 341               	.LCFI14:
 342 00fc 5F93      		push r21
 343               	.LCFI15:
 344 00fe 6F93      		push r22
 345               	.LCFI16:
 346 0100 8F93      		push r24
 347               	.LCFI17:
 348 0102 9F93      		push r25
 349               	.LCFI18:
 350 0104 AF93      		push r26
 351               	.LCFI19:
 352 0106 BF93      		push r27
 353               	.LCFI20:
 354 0108 CF93      		push r28
 355               	.LCFI21:
 356 010a DF93      		push r29
 357               	.LCFI22:
 358 010c EF93      		push r30
 359               	.LCFI23:
 360 010e FF93      		push r31
 361               	.LCFI24:
 362               	/* prologue: Signal */
 363               	/* frame size = 0 */
 364               	/* stack size = 16 */
 365               	.L__stack_usage = 16
 146:dimmer.c      **** 	count--;
 366               		.loc 1 146 0
 367 0110 8091 0000 		lds r24,count
 368 0114 9091 0000 		lds r25,count+1
 369 0118 0197      		sbiw r24,1
 370 011a 9093 0000 		sts count+1,r25
 371 011e 8093 0000 		sts count,r24
 372               	.LVL12:
 373 0122 A0E0      		ldi r26,lo8(dimmers+2)
 374 0124 B0E0      		ldi r27,hi8(dimmers+2)
 375 0126 E0E0      		ldi r30,lo8(dimmers+4)
 376 0128 F0E0      		ldi r31,hi8(dimmers+4)
 377 012a 80E0      		ldi r24,0
 378 012c 90E0      		ldi r25,0
 379               	.LBB15:
 147:dimmer.c      **** 	for(uint8_t i = 0; i < DIMMER_COUNT; i++) {
 148:dimmer.c      **** 		if(dimmers[i].level_cur > 0 && dimmers[i].level_cur >= count) {
 380               		.loc 1 148 0
 381 012e 65E0      		ldi r22,lo8(5)
 382               	.LVL13:
 383               	.L18:
 384 0130 689F      		mul r22,r24
 385 0132 E001      		movw r28,r0
 386 0134 699F      		mul r22,r25
 387 0136 D00D      		add r29,r0
 388 0138 1124      		clr __zero_reg__
 389 013a C050      		subi r28,lo8(-(dimmers))
 390 013c D040      		sbci r29,hi8(-(dimmers))
 391 013e 2881      		ld r18,Y
 392 0140 2223      		tst r18
 393 0142 01F0      		breq .L17
 394               		.loc 1 148 0 is_stmt 0 discriminator 1
 395 0144 4881      		ld r20,Y
 396 0146 2091 0000 		lds r18,count
 397 014a 3091 0000 		lds r19,count+1
 398 014e 50E0      		ldi r21,0
 399 0150 4217      		cp r20,r18
 400 0152 5307      		cpc r21,r19
 401 0154 00F0      		brlo .L17
 149:dimmer.c      **** 			*dimmers[i].port |= dimmers[i].mask;
 402               		.loc 1 149 0 is_stmt 1
 403 0156 CD91      		ld r28,X+
 404 0158 DC91      		ld r29,X
 405 015a 1197      		sbiw r26,1
 406 015c 2881      		ld r18,Y
 407 015e 3081      		ld r19,Z
 408 0160 232B      		or r18,r19
 409 0162 2883      		st Y,r18
 410               	.LVL14:
 411               	.LBB16:
 412               	.LBB17:
 413               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 414               		.loc 2 246 0
 415 0164 28E2      		ldi r18,lo8(40)
 416 0166 2A95      		1: dec r18
 417 0168 01F4      		brne 1b
 418               	.LBE17:
 419               	.LBE16:
 150:dimmer.c      **** 			_delay_us(10);
 151:dimmer.c      **** 			*dimmers[i].port ^= dimmers[i].mask;
 420               		.loc 1 151 0
 421 016a CD91      		ld r28,X+
 422 016c DC91      		ld r29,X
 423 016e 1197      		sbiw r26,1
 424 0170 2881      		ld r18,Y
 425 0172 3081      		ld r19,Z
 426 0174 2327      		eor r18,r19
 427 0176 2883      		st Y,r18
 428               	.LVL15:
 429               	.L17:
 430 0178 0196      		adiw r24,1
 431 017a 1596      		adiw r26,5
 432 017c 3596      		adiw r30,5
 147:dimmer.c      **** 	for(uint8_t i = 0; i < DIMMER_COUNT; i++) {
 433               		.loc 1 147 0
 434 017e 8230      		cpi r24,2
 435 0180 9105      		cpc r25,__zero_reg__
 436 0182 01F4      		brne .L18
 437               	/* epilogue start */
 438               	.LBE15:
 152:dimmer.c      **** 		}
 153:dimmer.c      **** 	}
 154:dimmer.c      **** }
 439               		.loc 1 154 0
 440 0184 FF91      		pop r31
 441 0186 EF91      		pop r30
 442 0188 DF91      		pop r29
 443 018a CF91      		pop r28
 444 018c BF91      		pop r27
 445 018e AF91      		pop r26
 446 0190 9F91      		pop r25
 447 0192 8F91      		pop r24
 448 0194 6F91      		pop r22
 449 0196 5F91      		pop r21
 450 0198 4F91      		pop r20
 451 019a 3F91      		pop r19
 452 019c 2F91      		pop r18
 453 019e 0F90      		pop r0
 454 01a0 0FBE      		out __SREG__,r0
 455 01a2 0F90      		pop r0
 456 01a4 1F90      		pop r1
 457 01a6 1895      		reti
 458               	.LFE14:
 460               	.global	__vector_14
 462               	__vector_14:
 463               	.LFB15:
 155:dimmer.c      **** 
 156:dimmer.c      **** //Dimming Interrupt
 157:dimmer.c      **** ISR(TIMER0_COMPA_vect) {
 464               		.loc 1 157 0
 465 01a8 1F92      		push r1
 466               	.LCFI25:
 467 01aa 0F92      		push r0
 468               	.LCFI26:
 469 01ac 0FB6      		in r0,__SREG__
 470 01ae 0F92      		push r0
 471 01b0 1124      		clr __zero_reg__
 472 01b2 8F93      		push r24
 473               	.LCFI27:
 474 01b4 9F93      		push r25
 475               	.LCFI28:
 476               	/* prologue: Signal */
 477               	/* frame size = 0 */
 478               	/* stack size = 5 */
 479               	.L__stack_usage = 5
 480               	.LVL16:
 481               	.LBB18:
 158:dimmer.c      **** 	for(uint8_t i = 0; i < DIMMER_COUNT; i++) {
 159:dimmer.c      **** 		if(dimmers[i].level_req > dimmers[i].level_cur) {
 482               		.loc 1 159 0
 483 01b6 9091 0000 		lds r25,dimmers+1
 484 01ba 8091 0000 		lds r24,dimmers
 485 01be 8917      		cp r24,r25
 486 01c0 00F0      		brlo .L24
 160:dimmer.c      **** 			dimmers[i].level_cur++;
 161:dimmer.c      **** 		} else if(dimmers[i].level_req < dimmers[i].level_cur) {
 487               		.loc 1 161 0
 488 01c2 9091 0000 		lds r25,dimmers+1
 489 01c6 8091 0000 		lds r24,dimmers
 490 01ca 9817      		cp r25,r24
 491 01cc 00F4      		brsh .L25
 162:dimmer.c      **** 			dimmers[i].level_cur--;
 492               		.loc 1 162 0
 493 01ce 8091 0000 		lds r24,dimmers
 494 01d2 8150      		subi r24,lo8(-(-1))
 495 01d4 00C0      		rjmp .L28
 496               	.L24:
 160:dimmer.c      **** 			dimmers[i].level_cur++;
 497               		.loc 1 160 0
 498 01d6 8091 0000 		lds r24,dimmers
 499 01da 8F5F      		subi r24,lo8(-(1))
 500               	.L28:
 501 01dc 8093 0000 		sts dimmers,r24
 502               	.L25:
 503               	.LVL17:
 159:dimmer.c      **** 		if(dimmers[i].level_req > dimmers[i].level_cur) {
 504               		.loc 1 159 0
 505 01e0 9091 0000 		lds r25,dimmers+6
 506 01e4 8091 0000 		lds r24,dimmers+5
 507 01e8 8917      		cp r24,r25
 508 01ea 00F4      		brsh .L26
 160:dimmer.c      **** 			dimmers[i].level_cur++;
 509               		.loc 1 160 0
 510 01ec 8091 0000 		lds r24,dimmers+5
 511 01f0 8F5F      		subi r24,lo8(-(1))
 512 01f2 00C0      		rjmp .L29
 513               	.L26:
 161:dimmer.c      **** 		} else if(dimmers[i].level_req < dimmers[i].level_cur) {
 514               		.loc 1 161 0
 515 01f4 9091 0000 		lds r25,dimmers+6
 516 01f8 8091 0000 		lds r24,dimmers+5
 517 01fc 9817      		cp r25,r24
 518 01fe 00F4      		brsh .L23
 519               		.loc 1 162 0
 520 0200 8091 0000 		lds r24,dimmers+5
 521 0204 8150      		subi r24,lo8(-(-1))
 522               	.L29:
 523 0206 8093 0000 		sts dimmers+5,r24
 524               	.LVL18:
 525               	.L23:
 526               	/* epilogue start */
 527               	.LBE18:
 163:dimmer.c      **** 		}
 164:dimmer.c      **** 	
 165:dimmer.c      **** 	}
 166:dimmer.c      **** }...
 528               		.loc 1 166 0
 529 020a 9F91      		pop r25
 530 020c 8F91      		pop r24
 531 020e 0F90      		pop r0
 532 0210 0FBE      		out __SREG__,r0
 533 0212 0F90      		pop r0
 534 0214 1F90      		pop r1
 535 0216 1895      		reti
 536               	.LFE15:
 538               		.comm	count,2,1
 539               		.comm	dimmers,10,1
 800               	.Letext0:
 801               		.file 3 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 dimmer.c
     /tmp/ccZo3r2f.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccZo3r2f.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccZo3r2f.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccZo3r2f.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccZo3r2f.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccZo3r2f.s:11     .text:0000000000000000 initIO
     /tmp/ccZo3r2f.s:66     .text:0000000000000038 initDimmers
                            *COM*:000000000000000a dimmers
     /tmp/ccZo3r2f.s:106    .text.startup:0000000000000000 main
     /tmp/ccZo3r2f.s:204    .text:0000000000000070 rampToLevel
     /tmp/ccZo3r2f.s:225    .text:0000000000000080 switchToLevel
     /tmp/ccZo3r2f.s:248    .text:0000000000000092 debugLed
     /tmp/ccZo3r2f.s:267    .text:000000000000009c __vector_1
                            *COM*:0000000000000002 count
     /tmp/ccZo3r2f.s:326    .text:00000000000000ec __vector_11
     /tmp/ccZo3r2f.s:462    .text:00000000000001a8 __vector_14

UNDEFINED SYMBOLS
__do_clear_bss
